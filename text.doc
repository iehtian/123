
#define HAVE_TYPEDEF_SUPPORT     1

typedef int test_int;
typedef long long int test_long_long_int;

int int_a;
int int_b = 0;
int int_c = 0,int_d = 1;

const float const_float_a = 0.0;
const double const_double_a = 0.f;
const int const_int_a = 0;
int const int_const_a = 0;
const static int const_static_int_a = 0;
static const int static_const_int_a = 0;
static int static_int_a = 0;
int static int_static_a = 0;
#if HAVE_TYPEDEF_SUPPORT
test_int test_int_a;
test_int test_int_a2 = 0;
const test_int const_test_int_a = 0;
static const test_int static_const_test_int_a = 0;
static test_int static_test_int_a = 0;
#endif

char *str_0 = "123\0";
char **str_0p2 = "123\0";
char *str_0a[] = "123\0";
char **str_0p2[] = "123\0";
volatile char *volatile_str_0 = "123\0";
char str_00[10];
char str_1[] = {"123\0"};
// char str_2[100] = {}; // {}作为初始化器的时候内部不允许为空,虽然大多数的编译器会当成{0}
char str_3[100] = {0};
char str_4[100] = {"\"123\0\""};

char str_5[100] = {[3] = 'a',[4] = 'b'};

char str_6[10][10] = {{'a','b'},{'a','b'}};
char str_7[10][10] = {{'a','b'},{[2] = 'a',[3] = 'b'}};
char str_8[10][10] = {{[2] = 'a',[3] = 'b'},{[2] = 'a',[3] = 'b'}};

const char *const_str_0 = "123\0";
const char const_str_00[10];
const char const_str_1[] = {"123\0"};
// const char const_str_2[100] = {}; // {}作为初始化器的时候内部不允许为空,虽然大多数的编译器会当成{0}
const char const_str_3[100] = {0};
const char const_str_4[100] = {"\"123\0\""};

static const char *static_const_str_0 = "123\0";
static const char  static_const_str_00[10];
static const char  static_const_str_1[] = {"123\0"};
// static const char static_const_str_2[100] = {}; // {}作为初始化器的时候内部不允许为空,虽然大多数的编译器会当成{0}
static const char static_const_str_3[100] = {0};
static const char static_const_str_4[100] = {"\"123\0\""};

static char *static_str_0 = "123\0";
static char  static_str_00[10];
static char  static_str_1[] = {"123\0"};
// static char static_str_2[100] = {}; // {}作为初始化器的时候内部不允许为空,虽然大多数的编译器会当成{0}
static char static_str_3[100] = {0};
static char static_str_4[100] = {"\"123\0\""};

enum test_enum{
    ZERO,
    ONE = 1,
    TWO = 2 + 3 * 5,
    THREE,
} test_enum_a;

void test_void() {
    return;
}
void test_void_void(void) {
    return;
}
int test_a() {
    return const_int_a;
}
int test_int_void(void) {
    return const_int_a;
}
inline int test_a_inline() {
    return const_int_a;
}
inline int test_int_void_inline(void) {
    return const_int_a;
}
int test_input_a(int arg_a);
extern int test_input_a_extern(int arg_a);
// int test_int_void_args(...) { // 不支持第一个参数是不定参数
//     return const_int_a;
// }
int test_input_a(int arg_a) {
    return arg_a;
}
int test_input_a_args(int arg_a,...) {
    return arg_a;
}

inline int test_input_a_inline(int arg_a) {
    return arg_a;
}
inline int test_input_a_args_inline(int arg_a,...) {
    return arg_a;
}

int test_input_a2(int arg_a) {
    int a;
    {
        int b;
    }

    {
        int c;
    }
    if(1){
        goto label;
    }
    if(1){
        goto label;
    }else
        a = 0;

    if(1){
        goto label;
    }else{
        a = 0;
    }

    if(1){
        goto label;
    }else if(0){
        a = 0;
    }

    if(1){
        goto label;
    }else if(0){
        a = 0;
    }else
        a = 1;

    if(1){
        goto label;
    }else if(0){
        a = 0;
    }else{
        a = 1;
    }

    if(1)
        goto label;
    else
        a = 0;

    if(1)
        goto label;
    else if(0)
        a = 0;

    if(1)
        goto label;
    else if(0)
        a = 0;
    else
        a = 1;

    switch(a){
        case 0:
        case 1:
        break;
        default:
        break;
    }
    switch(a){
        case 0:
        break;
        default:
        break;
    }
    switch(a){
        default:
        break;
        case 0:
        case 1:
        break;

        case 3:
        break;
    }
    do{

        goto label;
    }while(1);

    while(1){

    }

    while(1)
        a = 0;

    for(int i = 0; i < 10;i++){
        
    }

    for(int i = 0; i < 10, a > 10;i++){
        
    }

    for(int i = 0; i < 10;){
        
    }

    for(int i = 0; a > 0, i < 10;){
        
    }
    int i = 0;
    for(;i < 0;){
        
    }

    for(;i < 0;i++){
        i = 123;
    }

    for(;i < 0,a > 0;i++){
        
        i = 123;
    }

    for(;;i++){
        
    }


    for(;;){
        
    }

label:
    return arg_a;
}

struct{
    int a: 4;
    int b : 1;
} test_noalign_struct;

struct{
    int a;
    int b;
} test_anonymity_struct;

struct{
    int a;
    int b;
    enum {
        aa = 0,
        bb ,
        cc
    }aa;
} test_enum_struct;

struct test_struct{
    int a;
    int b;
    int c[100];
    int e[10];
    int d[]; // 必须是最后一个，这是C99对于C89新增的特性，用于动态大小的结构体
} test_struct;

struct test_struct2{
    int a;
    int b;
    struct test_struct ref_struct;
    int d[0]; // 必须是最后一个，这是C99对于C89新增的特性，用于动态大小的结构体
} test_struct2,test_struct22;

union {
    struct {
        int alltypes;
    } n;
    struct {
        int type;
        int intnode;
    } ni;
    struct {
        int type;
        double doublenode;
    } nf;
} u;


struct test_struct_arr{
    int a;
    int c[100];
    struct test_struct ref_struct;
    int b[]; // 必须是最后一个，这是C99对于C89新增的特性，用于动态大小的结构体
} test_struct_arr_a;

int test_input_struct(struct test_struct *arg_st) {
    test_struct_arr_a.b[0] = 10;
    test_struct_arr_a.c[0] = 100;
    test_struct_arr_a.ref_struct.c[0] = 100;
    test_struct_arr_a.ref_struct.d[0] = 100;
    char str[] = {"123456 %d %x 12345678890\n"};
    char str2[strlen(str) + 1];
    return 0;
}

int test_input_struct_args(struct test_struct *arg_st,...) {
    test_input_struct_args(NULL,1 + 22 * 33,2,3);
    return test_input_a(300);
}

int test_input_struct2(struct test_struct *arg_st,struct test_struct *arg_st2) {
    return 0;
}

int main(int argc,const char* argv[]) {
    
    int int_a;
    int int_b = 0;
    int int_c = 0,int_d = 1;

    const int const_int_a = 0;
    static const int static_const_int_a = 0;
    static int static_int_a = 0;

#if HAVE_TYPEDEF_SUPPORT
    test_int test_int_a;
    test_int test_int_a2 = 0;

    const test_int const_test_int_a = 0;
    static const test_int static_const_test_int_a = 0;
    static test_int static_test_int_a = 0;
#endif
    char *str_0 = "123\0";
    char str_00[10];
    char str_1[] = {"123\0"};
    // char str_2[100] = {};  // {}作为初始化器的时候内部不允许为空,虽然大多数的编译器会当成{0}
    char str_3[100] = {0};
    char str_4[100] = {"\"123\0\""};

    const char *const_str_0 = "123\0";
    const char const_str_00[10];
    const char const_str_1[] = {"123\0"};
    // const char const_str_2[100] = {}; // {}作为初始化器的时候内部不允许为空
    const char const_str_3[100] = {0};
    const char const_str_4[100] = {"\"123\0\""};

    static const char *static_const_str_0 = "123\0";
    static const char  static_const_str_00[10];
    static const char  static_const_str_1[] = {"123\0"};
    // static const char static_const_str_2[100] = {}; // {}作为初始化器的时候内部不允许为空
    static const char static_const_str_3[100] = {0};
    static const char static_const_str_4[100] = {"\"123\0\""};

    static char *static_str_0 = "123\0";
    static char  static_str_00[10];
    static char  static_str_1[] = {"123\0"};
    // static char static_str_2[100] = {}; // {}作为初始化器的时候内部不允许为空
    static char static_str_3[100] = {0};
    static char static_str_4[100] = {"\"123\0\""};

    int_a = 1;
    // postfix-expression [ expression ]
    str_1[0];
    str_1[0] = 0;
    str_1[0] = (0);
    str_1[0] = (0) + 1;
    str_1[0] = (0 + 1);
    str_1[0+1] = 0;
    str_1[0+1] = (0);
    str_1[0+1] = (0) + 1;
    str_1[0+1] = (0 + 1);
    // postfix-expression ( argument-expression-listopt )
    test_a();
    str_1[0] = test_a();
    str_1[0] = test_input_a(2);

    // postfix-expression . identifier
    test_struct.a;
    test_struct.a = 0;
    test_struct.b = 0;
    test_struct2.ref_struct.a = 0;
    test_struct2.ref_struct.b = 0;
    struct test_struct2 *test_struct2_p = &test_struct2;
    
    // postfix-expression -> identifier
    test_struct2_p->a;
    test_struct2_p->a = 0;
    test_struct2_p->b = 0;
    test_struct2_p->ref_struct.a = 0;
    test_struct2_p->ref_struct.b = 0;

    // postfix-expression ++
    int_a++;
    ++int_a;

    // postfix-expression --
    --int_a;
    int_a--;

    // ( type-name ) { initializer-list }
    // 初步判断应该是用于数组初始化，但是为什么必须type_name存疑。
    // 根据SDCC中的代码判断是C99独有的代码表达方式，SDCC都没有实现。
    // TODO: implement compound literals (C99)
    // https://en.cppreference.com/w/c/language/compound_literal
    // https://gcc.gnu.org/onlinedocs/gcc-10.3.0/gcc/Compound-Literals.html#Compound-Literals
    struct st {int a;int b;} st_a = (struct st) {1*10,100};
    st_a = (struct st){10*10,1000};
    
    // const 限定字符或宽字符数组类型的复合文字可以与字符串文字共享存储。
    (const char []){"abc"} == "abc"; // might be 1 or 0, unspecified
    
    // Each compound literal creates only a single object in its scope:
    // 每个复合文字在其范围内仅创建一个对象：

    // Because compound literals are unnamed, a compound literal cannot reference itself (a named struct can include a pointer to itself)
    // Although the syntax of a compound literal is similar to a cast, the important distinction is that a cast is a non-lvalue expression while a compound literal is an lvalue.
    // 由于复合文字是未命名的，因此复合文字无法引用自身（命名结构可以包含指向自身的指针）
    // 尽管复合文字的语法与强制转换类似，但重要的区别是强制转换是非左值表达式，而复合文字是左值。
    struct s {int i;} *p = 0, *q;
    p = &((struct s){ int_a++ });

    int *int_p = (int[]){2, 4}; // creates an unnamed static array of type int[2]
                            // initializes the array to the values {2, 4}
                            // creates pointer p to point at the first element of
                            // the array
    const float *pc = (const float []){1e0, 1e1, 1e2}; // read-only compound literal
    
    // argument-expression-list , assignment-expression
    int_a = 1,2,3,4,5,6;

    int int_int_a[3][5];
    int_int_a[0][2] = 100;

    // EXAMPLE In the function call
    // 示例 在函数调用中
    // (*pf[f1()]) (f2(), f3() + f4())
    int (*func_p[2])(int arg_a);
    func_p[0] = test_input_a;

    (func_p[0])(3);

    if(int_a == 0){

    }
    
    if(int_a == 0){
        
    }else{

    }
    
    if(int_a == 0){
        
    }else 
    if(int_a == 0){
        
    }

    if(int_a == 0)
        func_p[0] = test_input_a;

    // 示例3 具有指定的初始化器可以与复合字面值结合使用。使用复合字面值创建的结
    // 构对象可以传递给函数，而不依赖于成员顺序：
    struct test_struct *arg_st;
    test_input_struct(arg_st);
    test_input_struct(&(struct test_struct){.a=0,.b=1});
    test_input_struct2(&(struct test_struct){.a=0,.b=1},&(struct test_struct){.a=0,.b=1});

    // 可以通过如下结构指定只读复合字面值：
    (const float []){1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6};

    // 第一个始终具有静态存储期，并且具有char数组类型，但不一定可修改；当它们出现在函数体内
    // 时，后两个具有自动存储期，其中第一个是可修改的。
    "/tmp/fileXXXXXX";
    (char []){"/tmp/fileXXXXXX"};
    (const char []){"/tmp/fileXXXXXX"};

    // ++ unary-expression
    ++int_a;
    // -- unary-expression
    --int_a;

    // unary-operator cast-expression
    // unary-operator: one of & * + - ~ !
    +(int)int_a;
    -(int)int_a;
    (*(struct test_struct *)arg_st).a;
    struct st *st_a_p = &st_a;
    ~(int)int_a;
    !(int)int_a;
    sizeof(int_a);
    sizeof(struct test_struct);
    sizeof(struct test_struct *);
    sizeof int_a;

    // cast-expression
    (int)int_a;

    // multiplicative-expression * cast-expression
    1 * 2;
    // multiplicative-expression / cast-expression
    1 / 2;
    // multiplicative-expression % cast-expression
    1 % 2;

    // additive-expression + multiplicative-expression
    1 + 2;
    // additive-expression - multiplicative-expression
    1 - 2;

    // shift-expression << additive-expression
    1 << 2;

    // shift-expression >> additive-expression
    1 >> 2;

    // relational-expression < shift-expression
    1 < 2;

    // relational-expression > shift-expression
    1 > 2;

    // relational-expression <= shift-expression
    1 <= 2;

    // relational-expression >= shift-expression
    1 >= 2;

    // equality-expression == relational-expression
    1 == 2;

    // equality-expression != relational-expression
    1 != 2;

    // AND-expression & equality-expression
    1 & 2;

    // exclusive-OR-expression ^ AND-expression
    1 ^ 2;

    // inclusive-OR-expression | exclusive-OR-expression
    1 | 2;

    // logical-AND-expression && inclusive-OR-expression
    1 && 2;

    // logical-OR-expression || logical-AND-expression
    1 || 2;

    // logical-OR-expression ? expression : conditional-expression
    1 ? 2 : 3;

    // assignment-expression
    int_a = 0;
    int_a *= 0;
    int_a /= 10;
    int_a %= 10;
    int_a += 0;
    int_a -= 0;
    int_a <<= 0;
    int_a >>= 0;
    int_a &= 0;
    int_a ^= 0;
    int_a |= 0;

    // expression , assignment-expression
    int_a = 1,2,3,4,5,6,7;

    return 0;
}

struct {
    int a;
    int :1;
}a;



// int array[static const 10]; // error: static or type qualifiers in non-parameter array declarator

// 在这个例子中，static 关键字指示数组的大小至少为10，
// 而函数参数列表中的 array 参数是一个指向至少包含10个元素的整数数组的指针。
void func(int array[static 10]) {
    // 函数体
}


// 错误提示表明在非参数数组声明符中使用了 static 或类型限定符。
// 根据 C 语言的语法规则，static 和类型限定符通常用于指示函数参数列表中的数组大小，并不适用于普通的数组声明中。

// 函数声明，参数列表中的数组大小至少为10
void function(int array[static 10]);

// 函数声明，参数列表中的数组大小至少为5
void anotherFunction(float numbers[static const 5]);

// 函数声明，参数列表中的数组大小至少为N，N是常量表达式
void someFunction(double data[static sizeof(int)]);

// 函数声明，参数列表中的数组大小至少为3
void someFunction2(char buffer[static 3]);

// 函数声明，参数列表中的数组大小至少为100
void processNumbers(int data[static 100]);

// 函数声明，参数列表中的数组大小至少为5
void calculate(float values[static const 5]);

// 函数声明，参数列表中的数组大小至少为N，N是一个宏定义
#define SIZE 20
void process(int array[static SIZE]);
// 这些示例展示了在函数参数列表中使用静态数组大小指定符号的不同情况。
// 在这些声明中，static 关键字表示数组的大小至少为指定的值，而 const 关键字用于指示该值是一个常量，不能被修改。


// 函数声明，参数列表中的数组大小至少为5
void calculate(float values[const static 5]);

void func_a(d,b,c){

}

/*
void calculate2(float values[const static 5]); 和 void calculate2(float values[static const 5]);一样吗？
在C语言中，const 和 static 关键字的位置对数组声明的语义影响是不同的，因此这两个声明并不完全相同。

void calculate2(float values[const static 5]);：这种形式表示数组的大小是一个静态的常量，且该常量为不可修改的。也就是说，这个声明表示数组大小至少为 5，而且这个大小是静态的，在编译时已经确定，不能被修改。

void calculate2(float values[static const 5]);：这种形式表示数组的大小是一个常量，且该常量是静态的。这个声明也表示数组大小至少为 5，但是 const 关键字在这里表示该大小是一个常量，不能被修改。

这两种形式在语义上有所不同，但在一些编译器中，它们可能会被解释为相同的含义。然而，根据C语言标准的严格解释，它们有着不同的语义。

*/

int func_b(int ba, int bb, int bc){
    int *a = (int[])0;
}

int func_bb(int ba, int bb, int bc(int[])){
    int *a = (int[])0;
}

int f(void); // 声明一个没有参数返回int的函数f
int *fip(); // 声明一个没有参数规定返回int指针的函数fip
int (*pfi)(); // 声明一个指向没有参数规定返回int的函数的指针pfi

// 当一个括号内部既包含id也包含指针的时候，这是个函数指针。